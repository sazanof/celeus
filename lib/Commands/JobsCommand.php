<?php

namespace Vorkfork\Commands;

use Symfony\Component\Console\Attribute\AsCommand;
use Symfony\Component\Console\Command\Command;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Output\OutputInterface;
use Vorkfork\Core\Models\Job;
use \Vorkfork\Core\Jobs\Job as JobCommand;

#[AsCommand(name: 'app:jobs', description: 'Execute jobs one by one')]
class JobsCommand extends Command
{
	protected ?Job $job;

	protected function configure()
	{
		parent::configure(); // TODO: Change the autogenerated stub
	}

	protected function execute(InputInterface $input, OutputInterface $output)
	{
		while (true) {
			$this->job = $this->getLastOne(); // Get new job
			if (!is_null($this->job)) {
				$this->job->setStatus(JobCommand::STATUS_RUNNING);
				$this->job->em()->flush();
				$output->writeln('START ' . $this->job->getClass() . ' job');
				JobCommand::execute($this->job, function (Job $jobModel, $success) use ($output) {
					$this->job = Job::find($jobModel->getId());
					if ($success) {
						$output->writeln('SUCCESS ' . $this->job->getClass() . ' job');
						$this->job->setStatus(JobCommand::STATUS_FINISHED);
					} else {
						$output->writeln('ERROR ' . $this->job->getClass() . ' job');
						$this->job->setStatus(JobCommand::STATUS_FAILED);
					}
					$this->job->em()->flush();
				});
			};
			sleep(1);
		}
		return Command::SUCCESS;
	}

	public function getLastOne()
	{
		return Job::repository()->getLastNewJob();
	}
}
